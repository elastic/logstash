require "treetop"
require "logstash/config/config_ast"

grammar LogStashConfig
  include LogStash::Config::AST

  rule config
    _ _item:plugin_section _ _items:( _ _item:plugin_section )* _ <Config>
  end

  rule comment
    ( whitespace? "#" [^\r\n]* "\r"? "\n" )+
  end

  rule _
    ( comment / whitespace )* <Whitespace>
  end

  rule whitespace
    [ \t\r\n]+ <Whitespace>
  end

  rule optional_comma
    whitespace _ / comma
  end

  rule comma
    _ "," _
  end

  rule key_value_separator
    _ ( "=>" / ":" ) _
  end

  rule plugin_section
    plugin_type _ "{"
      _ ( branch_or_plugin _ )*
    "}"
    <PluginSection>
  end

  rule branch_or_plugin
    branch / plugin
  end

  rule plugin_type
    "input" / "filter" / "output"
  end

  rule plugins
    ( plugin ( _ plugin )* )?
  end

  rule plugin
    name _ "{"
      _
      _items:( _item:attribute _items:( optional_comma _item:attribute )* )?
      _
    "}"
    <Plugin>
  end

  rule name
    [A-Za-z0-9_-]+ <UnicodeValue> / string
  end

  rule attribute
    name key_value_separator value:( plugin / value ) <KVPair>
  end

  # Values

  rule value
    null / boolean / bareword / string / regexp / number / array / hash
  end

  rule null
    "null" <Value> {
      def content
        'nil'
      end
    }
  end

  rule boolean
    "true" <Value> / "false" <Value>
  end

  rule bareword
    [A-Za-z_] [A-Za-z0-9_]+ <UnicodeValue>
  end

  rule double_quoted_string
    '"' ( "\\" . / [^\"] )* '"' <UnicodeValue> {
      def content
        json_parse_value(text_value)
      end
    }
  end

  rule single_quoted_string
    "'" content:(( !"'" . )*) "'" <UnicodeValue>
  end

  rule string
    double_quoted_string / single_quoted_string
  end

  rule regexp
    '/' content:( ( '\/' / !'/' . )* ) '/' <RegexpValue>
  end

  rule number
    "-"? [0-9]+ ("." [0-9]*)? ( [eE] [+-]? [0-9]+ )? <Value>
  end

  rule array
    "[" _ _items:( _item:value _items:( comma _item:value )* )? _ "]" <CompositeValue>
  end

  rule hash
    "{" _ _items:( _item:hashentry _items:( optional_comma _item:hashentry)* )? _ "}" <CompositeValue>
  end

  rule hashentry
    name:(number / bareword / string) key_value_separator value <KVPair>
  end

  # Conditionals

  rule branch
    if (_ else_if)* (_ else)? <BranchSet>
  end

  rule if
    "if" _ condition _ branch_body <Branch>
  end

  rule else_if
    "else" _ "if" _ condition _ branch_body <Branch> {
      def keyword
        "elsif"
      end
    }
  end

  rule else
    "else" _ branch_body <Branch>
  end

  rule branch_body
    "{" _ body:( branch_or_plugin _ )* "}" <BranchBody>
  end

  # Conditions and expressions

  rule condition
    expression (_ ( and_op / or_op / xor_op / nand_op ) _ expression)* <Parenthesised>
  end
  rule and_op  "and"  <Operator> end
  rule or_op   "or"   <Operator> end
  rule xor_op  "xor"  <Operator> end
  rule nand_op "nand" <Operator> end

  rule expression
    ( ( "(" _ condition _ ")" )
      / negated_expression
      / in_expression
      / compare_expression
      / regexp_expression
      / rvalue ) <Parenthesised>
  end

  rule negated_expression
    negate_op _ expression <Parenthesised>
  end
  rule negate_op "!" <Operator> end

  rule in_expression
    needle:rvalue _ negated:( "not" _ )? "in" _ haystack:rvalue <InExpression>
  end

  rule method_call
    method _ "(" _
      _items:( _item:rvalue _items:( comma _item:rvalue )* )?
    _ ")"
    <MethodCall>
  end

  rule method
    bareword
  end

  rule compare_expression
    rvalue _ ( eq_op / ne_op / le_op / ge_op / lt_op / gt_op ) _ rvalue
  end
  rule eq_op "==" <Operator> end
  rule ne_op "!=" <Operator> end
  rule le_op "<=" <Operator> end
  rule ge_op ">=" <Operator> end
  rule lt_op "<"  <Operator> end
  rule gt_op ">"  <Operator> end

  rule regexp_expression
    rvalue _ (re_match_op / re_not_match_op) _ (string <Regexped> / regexp)
    <Parenthesised>
  end
  rule re_match_op     "=~" <Operator> end
  rule re_not_match_op "!~" <Operator> end

  rule rvalue
    selector / method_call / value
  end

  rule selector
    selector_element+ <Selector>
  end

  rule selector_element
    "[" [^\], ]+ "]"
  end
end
